#redimensiona as imagens para 640x640

import os
from PIL import Image

# Caminho da pasta de entrada (onde estÃ£o as imagens originais)
pasta_origem = "/content/drive/MyDrive/cibernetica/Proj2/imagens_buriti"  # Substitua pelo caminho correto

# Caminho da pasta de saÃ­da (onde serÃ£o salvas as imagens redimensionadas)
pasta_saida = "/content/drive/MyDrive/cibernetica/Proj2/imagens_buriti_red"
os.makedirs(pasta_saida, exist_ok=True)

# DimensÃ£o desejada
nova_largura = 640
nova_altura = 640

# Processa todas as imagens na pasta de origem
for arquivo in os.listdir(pasta_origem):
    caminho_completo = os.path.join(pasta_origem, arquivo)

    # Verifica se Ã© uma imagem (extensÃµes comuns)
    if arquivo.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif', '.tiff')):
        try:
            # Abre a imagem
            img = Image.open(caminho_completo)

            # Redimensiona mantendo proporÃ§Ã£o e preenchendo para 640x640
            img = img.resize((nova_largura, nova_altura), Image.LANCZOS)

            # Salva na pasta de saÃ­da
            novo_nome = arquivo[-9:]
            caminho_saida = os.path.join(pasta_saida, novo_nome)
            img.save(caminho_saida)

            print(f"Imagem {arquivo} redimensionada e salva!")
        except Exception as e:
            print(f"Erro ao processar {arquivo}: {e}")

print("Processo concluÃ­do!")


#altera o nome dos arquivos de rotulos para somente o nÃºmero da imagem 
import os
import shutil

# ðŸ“Œ Defina os caminhos das pastas
pasta_origem = "/content/drive/MyDrive/cibernetica/Proj2/labels"  # Altere para o caminho correto
pasta_destino = "/content/drive/MyDrive/cibernetica/Proj2/labels_1"  # Altere para o caminho correto

# Criar a pasta de destino, se nÃ£o existir
os.makedirs(pasta_destino, exist_ok=True)

# ðŸ”„ Percorrer todos os arquivos na pasta de origem
for nome_arquivo in os.listdir(pasta_origem):
    if nome_arquivo.endswith(".txt"):  # Filtrar apenas arquivos .txt
        caminho_origem = os.path.join(pasta_origem, nome_arquivo)

        # ðŸ“Œ Criar o novo nome com os Ãºltimos 5 caracteres
        novo_nome = nome_arquivo[-9:]  # Ãšltimos 5 caracteres do nome
        caminho_destino = os.path.join(pasta_destino, novo_nome)

        # ðŸ“Œ Copiar o arquivo
        shutil.copy2(caminho_origem, caminho_destino)
        print(f"ðŸ“„ {nome_arquivo} â†’ {novo_nome}")

print("âœ… Arquivos copiados com sucesso!")


#gera lista com as imagens em formato aleatorio

import os
import random

# ðŸ“Œ Defina o caminho da pasta e o arquivo de saÃ­da
pasta_origem = "/content/drive/MyDrive/cibernetica/Proj2/imagens_buriti_red"  # Altere para o caminho correto
arquivo_saida = "/content/drive/MyDrive/cibernetica/Proj2/img_list/lista_arquivos.txt"  # Nome do arquivo de saÃ­da

# ðŸ“Œ Obter a lista de arquivos na pasta
arquivos = os.listdir(pasta_origem)

# ðŸ”„ Embaralhar a lista de arquivos aleatoriamente
random.shuffle(arquivos)

# ðŸ“Œ Salvar a lista embaralhada em um arquivo .txt
with open(arquivo_saida, "w") as f:
    for arquivo in arquivos:
        f.write(arquivo + "\n")

print(f"âœ… Lista de arquivos aleatÃ³ria salva em: {arquivo_saida}")

#converte o formato dos rotutos de YOLO para formato COCO

import os
import shutil
import json
from PIL import Image

# Caminhos das pastas
base_dir = '/content/drive/MyDrive/cibernetica/Proj2'
images_dir = os.path.join(base_dir, 'imagens_buriti_red')
annotations_dir = os.path.join(base_dir, 'bbox')
img_list_dir = os.path.join(base_dir, 'img_list')

# Novos diretÃ³rios
output_dir = '/content/RT-DETR/rtdetr_pytorch/configs/dataset'
output_images_dir = os.path.join(output_dir, 'images')
output_annotations_dir = os.path.join(output_dir, 'annotations')

# Garantir que os diretÃ³rios de saÃ­da existem
os.makedirs(output_images_dir, exist_ok=True)
os.makedirs(output_annotations_dir, exist_ok=True)

# FunÃ§Ã£o para processar um conjunto (train, val ou test)
def process_set(set_name, verbose=True):
    # Criar diretÃ³rio para as imagens do conjunto
    set_images_dir = os.path.join(output_images_dir, set_name)
    os.makedirs(set_images_dir, exist_ok=True)

    # Ler a lista de imagens
    set_list_file = os.path.join(img_list_dir, f'{set_name}.txt')
    if verbose:
        print(f"Processando conjunto '{set_name}'...")

    with open(set_list_file, 'r') as f:
        image_files = [line.strip() for line in f.readlines()]

    images = []
    annotations = []
    annotation_id = 1  # ID Ãºnico para cada anotaÃ§Ã£o
    for image_id, image_file in enumerate(image_files, 1):
        # Copiar a imagem para o diretÃ³rio correspondente
        src_image_path = os.path.join(images_dir, image_file)
        dst_image_path = os.path.join(set_images_dir, image_file)
        shutil.copyfile(src_image_path, dst_image_path)
        if verbose:
            print(f"Copiando imagem '{image_file}': de {src_image_path} para {dst_image_path} ...")

        # Obter as dimensÃµes da imagem
        with Image.open(src_image_path) as img:
            width, height = img.size
            if verbose:
                print(f"DimensÃµes da imagem '{image_file}': {width}x{height}")

        # Adicionar entrada para a imagem
        images.append({
            'id': image_id,
            'file_name': image_file,
            'width': width,
            'height': height
        })

        # Ler o arquivo de anotaÃ§Ãµes correspondente
        annotation_file = os.path.splitext(image_file)[0] + '.txt'
        annotation_path = os.path.join(annotations_dir, annotation_file)
        if os.path.exists(annotation_path):
            with open(annotation_path, 'r') as f:
                lines = f.readlines()

            for line in lines:
                line = line.strip()
                if not line:
                    continue

                parts = line.split()
                if len(parts) != 5:
                    print(f"Aviso: Formato invÃ¡lido na linha '{line}' do arquivo '{annotation_path}'.")
                    continue

                try:
                    x_centro, y_centro, w, h = map(float, parts[1:])

                except ValueError:
                    print(f"Aviso: Valores nÃ£o numÃ©ricos na linha '{line}' do arquivo '{annotation_path}'.")
                    continue
                # Converter para coordenadas absolutas em pixels
                x_min = int((x_centro - w / 2) * width)
                y_min = int((y_centro - h / 2) * height)
                x_max = int((x_centro + w / 2) * width)
                y_max = int((y_centro + h / 2) * height)

                # Garantir que as coordenadas estÃ£o dentro dos limites da imagem
                x_min = max(0, min(x_min, width - 1))
                y_min = max(0, min(y_min, height - 1))
                x_max = max(0, min(x_max, width - 1))
                y_max = max(0, min(y_max, height - 1))

                bbox_width = x_max - x_min
                bbox_height = y_max - y_min

                if bbox_width <= 0 or bbox_height <= 0:
                    print(f"Aviso: BBox com largura ou altura zero na imagem '{image_file}'.")
                    continue


                annotations.append({
                    'id': annotation_id,
                    'image_id': image_id,
                    'category_id': 0,  # ID da categoria (apenas uma classe)
                    'bbox': [x_min, y_min, bbox_width, bbox_height],
                    'area': bbox_width * bbox_height,
                    'iscrowd': 0

                })
                annotation_id += 1
        else:
            print(f"Aviso: Arquivo de anotaÃ§Ã£o '{annotation_path}' nÃ£o encontrado.")

    # Criar a estrutura final do JSON
    coco_format = {
        'images': images,
        'annotations': annotations,
        'categories': [
            {
                'id': 0,
                'name': 'Copa de Arvore',  # Nome da classe
                'supercategory': 'none'
            }
        ]
    }

    # Salvar o arquivo JSON
    json_file = os.path.join(output_annotations_dir, f'instances_{set_name}.json')
    with open(json_file, 'w') as f:
        json.dump(coco_format, f, indent=4)

    print(f"Processamento do conjunto '{set_name}' concluÃ­do. {len(images)} imagens e {len(annotations)} anotaÃ§Ãµes processadas.")

# Processar os conjuntos de dados
for set_name in ['train', 'val', 'test']:
    process_set(set_name, verbose=False)
